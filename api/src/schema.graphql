type Member {
  id: ID! @id
  firstName: String #@search
  middleName: String
  lastName: String #@search
  email: String
  phoneNumber: String
  whatsappNumber: String #@unique
  pictureUrl: String
  gender: Gender @relation(name: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus
    @relation(name: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relation(name: "WAS_BORN_ON", direction: OUT)
  title: [HasTitle]
  ministry: Ministry @relation(name: "BELONGS_TO", direction: OUT)
  occupation: Occupation @relation(name: "HAS_OCCUPATION", direction: OUT)
  # Church Details
  history: [HistoryLog] @relation(name: "HAS_HISTORY", direction: OUT)
  bacenta: Bacenta @relation(name: "BELONGS_TO", direction: OUT)
  leadsBacenta: [Bacenta] @relation(name: "LEADS", direction: OUT)
  leadsCentre: [Centre] @relation(name: "LEADS", direction: OUT)
  leadsMinistry: [Ministry] @relation(name: "LEADS", direction: OUT)
  leadsSonta: [Sonta] @relation(name: "LEADS", direction: OUT)
  leadsBasonta: [Basonta] @relation(name: "LEADS", direction: OUT)
  leadsTown: [Town] @relation(name: "LEADS", direction: OUT)
  leadsCampus: [Campus] @relation(name: "LEADS", direction: OUT)
  townBishop: [Town] @relation(name: "HAS_TOWN", direction: OUT)
  campusBishop: [Campus] @relation(name: "HAS_CAMPUS", direction: OUT)
  isBishopAdminFor: [Member] @relation(name: "IS_ADMIN_FOR", direction: OUT)
  isCampusAdminFor: [Campus] @relation(name: "IS_ADMIN_FOR", direction: OUT)
  isTownAdminFor: [Town] @relation(name: "IS_ADMIN_FOR", direction: OUT)
  hasAdmin: Member @relation(name: "IS_ADMIN_FOR", direction: IN)
}

type Gender {
  gender: String
  members: [Member] @relation(name: "HAS_GENDER", direction: IN)
}

type MaritalStatus {
  status: String
  members: [Member] @relation(name: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation {
  occupation: String
  members: [Member] @relation(name: "HAS_OCCUPATION", direction: IN)
}

type Title {
  title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [HasTitle]
}

type HasTitle @relation(name: "HAS_TITLE") {
  from: Member
  to: Title
  yearAppointed: Date
  status: String #active or inactive
  numberofTimesRemoved: Int
}

type HasBacentaHistory @relation(name: "HAS_HISTORY") {
  from: Bacenta
  to: HistoryLog
  pointer: Boolean
}
type HasCentreHistory @relation(name: "HAS_HISTORY") {
  from: Centre
  to: HistoryLog
  pointer: Boolean
}
type HasCampusHistory @relation(name: "HAS_HISTORY") {
  from: Campus
  to: HistoryLog
  pointer: Boolean
}
type HasTownHistory @relation(name: "HAS_HISTORY") {
  from: Town
  to: HistoryLog
  pointer: Boolean
}

type TimeGraph {
  date: Date @index
  memberDob: Member @relation(name: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relation(name: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: TimeGraph
    @relation(name: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relation(name: "LEADER_ENDED_ON", direction: OUT)
  historyDate: TimeGraph @relation(name: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecords] @relation(name: "SERVICE_DATE", direction: IN)
}

# type LeaderHistory {
#   created_at: DateTime
#   historyRecord: String
#   historyDate: TimeGraph
#     @relation(name: "LEADER_STARTED_ON", direction: OUT)
#   historyEndDate: TimeGraph @relation(name: "LEADER_ENDED_ON", direction: OUT)
#   leaders: Member @relation(name: "HAS_LEADERSHIP_HISTORY", direction: IN)
#   bacentaerviceRecords: [ServiceRecords]
#     @relation(name: "HAS_RECORDS", direction: OUT)
# }

type ServiceRecords {
  created_at: DateTime
  bacenta: Bacenta @relation(name: "HAS_RECORDS", direction: IN)
  centre: Centre @relation(name: "HAS_RECORDS", direction: IN)
  campus: Campus @relation(name: "HAS_RECORDS", direction: IN)
  town: Town @relation(name: "HAS_RECORDS", direction: IN)
  serviceDate: TimeGraph @relation(name: "SERVICE_DATE", direction: OUT)
  attendance: Int
  income: Float
  treasurer1ID: String!
  treasurer2ID: String!
  leaderHistory: HistoryLog @relation(name: "HAS_RECORDS", direction: IN)
}

type HistoryLog {
  id: ID @id
  timeStamp: Time
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relation(name: "RECORDED_ON", direction: OUT)
  leaders: [Member] @relation(name: "HAS_HISTORY", direction: IN)
  Bacenta: [Bacenta] @relation(name: "HAS_HISTORY", direction: IN)
  Centre: [Centre] @relation(name: "HAS_HISTORY", direction: IN)
  Campus: [Campus] @relation(name: "HAS_HISTORY", direction: IN)
  Town: [Town] @relation(name: "HAS_HISTORY", direction: IN)
}

# Campus-Centre, Town-Centre
type Campus {
  id: ID @id
  name: String
  leader: Member @relation(name: "LEADS", direction: IN)
  sontas: [Sonta] @relation(name: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relation(name: "HAS_CENTRE", direction: OUT)
  bishop: Member @relation(name: "HAS_CAMPUS", direction: IN)
  admin: Member @relation(name: "IS_ADMIN_FOR", direction: IN)
  history: [HasCampusHistory]
  serviceRecords: [ServiceRecords]
    @relation(name: "HAS_RECORDS", direction: OUT)
}

type Town {
  id: ID @id
  name: String
  leader: Member @relation(name: "LEADS", direction: IN)
  sontas: [Sonta] @relation(name: "HAS_SONTA", direction: OUT)
  centres: [Centre] @relation(name: "HAS_CENTRE", direction: OUT)
  bishop: Member @relation(name: "HAS_TOWN", direction: IN)
  admin: Member @relation(name: "IS_ADMIN_FOR", direction: IN)
  history: [HasTownHistory]
  serviceRecords: [ServiceRecords]
    @relation(name: "HAS_RECORDS", direction: OUT)
}

type Centre {
  id: ID @id
  name: String #
  leader: Member @relation(name: "LEADS", direction: IN)
  bacentas: [Bacenta] @relation(name: "HAS_BACENTA", direction: OUT)
  basontas: Basonta @relation(name: "HAS_BASONTA", direction: OUT)
  town: Town @relation(name: "HAS_CENTRE", direction: IN)
  campus: Campus @relation(name: "HAS_CENTRE", direction: IN)
  history: [HasCentreHistory]
  serviceRecords: [ServiceRecords]
    @relation(name: "HAS_RECORDS", direction: OUT)
}

# Shared Units: Bacenta, Bacenta, Sonta
type Bacenta {
  id: ID @id
  name: String #
  centre: Centre @relation(name: "HAS_BACENTA", direction: IN)
  location: Point
  leader: Member @relation(name: "LEADS", direction: IN)
  members: [Member] @relation(name: "BELONGS_TO", direction: IN)
  meetingDay: ServiceDay @relation(name: "MEETS_ON_DAY", direction: OUT)
  history: [HasBacentaHistory]
  serviceRecords: [ServiceRecords]
    @relation(name: "HAS_RECORDS", direction: OUT)
}

type ServiceDay {
  day: String!
  dayNum: Int
  bacenta: Bacenta @relation(name: "MEETS_ON_DAY", direction: IN)
}

type Ministry {
  id: ID @id
  name: String
  sonta: [Sonta] @relation(name: "HAS_SONTA", direction: OUT)
  leader: Member @relation(name: "LEADS", direction: IN)
  members: [Member] @relation(name: "BELONGS_TO", direction: IN)
}

type Sonta {
  id: ID @id
  name: String
  leader: Member @relation(name: "LEADS", direction: IN)
  basonta: [Basonta] @relation(name: "HAS_BASONTA", direction: OUT)
  ministry: Ministry @relation(name: "HAS_SONTA", direction: IN)
  town: Town @relation(name: "HAS_SONTA", direction: IN)
  campus: [Campus] @relation(name: "HAS_SONTA", direction: IN)
}
type Basonta {
  id: ID @id
  name: String
  leader: Member @relation(name: "LEADS", direction: IN)
  centre: Centre @relation(name: "HAS_BASONTA", direction: IN)
}

#Query Definitions
type Query {
  #At the Federal Level
  bishopsList: [Member]
    @cypher(
      statement: "MATCH ()<-[:HAS_CAMPUS|:HAS_TOWN]-(m:Member) RETURN DISTINCT m"
    )
  bishopsListCampus: [Member]
    @cypher(statement: "MATCH ()<-[:HAS_CAMPUS]-(m:Member) RETURN DISTINCT m")
  bishopsListTown: [Member]
    @cypher(statement: "MATCH ()<-[:HAS_TOWN]-(m:Member) RETURN DISTINCT m")
  ministryList: [Ministry] @cypher(statement: "MATCH (m:Ministry) RETURN m")
  memberCount: Int!
    @cypher(statement: "MATCH (m:Member) RETURN COUNT(DISTINCT m)")
  centreCount: Int!
    @cypher(statement: "MATCH (b:Centre) RETURN COUNT(DISTINCT c)")
  bacentaCount: Int!
    @cypher(statement: "MATCH (b:Bacenta) RETURN COUNT( DISTINCT b)")
  federalPastorList(id: ID): [Member]
    @cypher(statement: "MATCH (t:Title)<-[:HAS_TITLE]-(m:Member) RETURN m")

  #At the Episcopal Level
  bishopCampusTownCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t) RETURN COUNT(DISTINCT t)"
    )
  bishopCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]-(c) RETURN COUNT(DISTINCT c)"
    )
  bishopBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]-()-[:HAS_BACENTA]-(b) RETURN COUNT(DISTINCT b)"
    )
  bishopBacentaDropdown(id: ID, bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (b:Bacenta)<-[]-(:Centre)<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) WHERE toLower(b.name) CONTAINS toLower($bacentaName) RETURN b"
    )
  bishopsSontaMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s)
      RETURN m
      """
    )
  bishopSontaMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s)
      RETURN COUNT(DISTINCT m)
      """
    )
  bishopSontaMemberCountList(bishopId: ID): [Ministry]!
    @cypher(
      statement: """
      MATCH (:Member {id: $bishopId})-[:HAS_TOWN|:HAS_CAMPUS]->()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(s:Ministry)
      RETURN s, COUNT(DISTINCT m)
      """
    )
  bishopPastorCount(id: ID): Int!
    @cypher(
      statement: "MATCH (t:Title)<-[:HAS_TITLE]-(m:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()-[:HAS_CENTRE]-()-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN COUNT( DISTINCT m)"
    )
  bishopPastorList(id: ID): [Member]
    @cypher(
      statement: "MATCH (t:Title)<-[:HAS_TITLE]-(m:Member)-[:BELONGS_TO]->()<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-()<-[:HAS_TOWN|:HAS_CAMPUS]-(:Member {id: $id}) RETURN m"
    )
  bishopMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t)
      MATCH (t)-[:HAS_CENTRE]->(com)
      MATCH (com)-[:HAS_BACENTA]->(c)
      MATCH (c)<-[:BELONGS_TO*]-(m:Member)
      RETURN m
      """
    )
  bishopMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS_TOWN|:HAS_CAMPUS]->(t)
      MATCH (t)-[:HAS_CENTRE]->(com)
      MATCH (com)-[:HAS_BACENTA]->(c)
      MATCH (c)<-[:BELONGS_TO*]-(m:Member)
      RETURN COUNT(DISTINCT m)
      """
    )
  campusMemberList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (:Campus {id:$id})-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(c:Member)
      RETURN DISTINCT c
      """
    )
  townMemberList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (:Town {id:$id})-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(t:Member)
      RETURN DISTINCT t
      """
    )

  #At the Town Level
  displayTown(id: ID): Town
    @cypher(statement: "MATCH (t:Town {id:$id}) RETURN t")
  townList(id: ID): [Town]
    @cypher(
      statement: "MATCH (ttl:Title {title:'Bishop'})<-[:HAS_TITLE]-(a:Member {id:$id})-[:HAS_TOWN]->(t:Town) RETURN t"
    )
  townBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: "MATCH (t:Town {id: $id})-[:HAS_CENTRE]->(:Centre)-[:HAS_BACENTA]-> (c:Bacenta) RETURN c"
    )
  townSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (t:Town {id: $id})-[:HAS_SONTA]->(s:Sonta)  RETURN s"
    )
  townCentreList(id: ID): [Centre]
    @cypher(
      statement: "MATCH (t:Town {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN c"
    )
  townCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Town {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN COUNT(c)"
    )
  townBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[]-()-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)"
    )
  townSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[:HAS_SONTA]->(s:Sonta) RETURN COUNT(s)"
    ) 
  townMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id:$id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(DISTINCT m)"
    )
  townSontaMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Town {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) MATCH (m)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT m)"
    )

  #At the Campus Level
  displayCampus(id: ID): Campus
    @cypher(statement: "MATCH (t:Campus {id:$id}) RETURN t")
  campusList(id: ID): [Campus]
    @cypher(
      statement: "MATCH (ttl:Title {title:'Bishop'})<-[:HAS_TITLE]-(a:Member {id:$id})-[:HAS_CAMPUS]->(c:Campus) RETURN c"
    )
  campusBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: "MATCH (t:Campus {id: $id})-[:HAS_CENTRE]->(:Centre)-[:HAS_BACENTA]-> (c:Bacenta) RETURN c"
    )
  campusSontaList(id: ID): [Sonta]
    @cypher(
      statement: "MATCH (t:Campus {id: $id})-[:HAS_SONTA]->(s:Sonta)  RETURN s"
    )
  campusCentreList(id: ID): [Centre]
    @cypher(
      statement: "MATCH (t:Campus {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN c"
    )
  campusCentreCount(id: ID): Int!
    @cypher(
      statement: "MATCH(:Campus {id:$id})-[:HAS_CENTRE]->(c:Centre) RETURN COUNT(c)"
    )
  campusBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[]-()-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)"
    )
  campusSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[:HAS_MINISTRY]->(s:Sonta) RETURN COUNT(s)"
    )
  campusMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id:$id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(DISTINCT m)"
    )
  campusSontaMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Campus {id: $id})-[]-(:Centre)-[]->(:Bacenta)<-[:BELONGS_TO]-(m:Member) MATCH (m)-[:BELONGS_TO]->(:Ministry) RETURN COUNT(DISTINCT m)"
    )

  #At the Centre Level
  displayCentre(id: ID): Centre
    @cypher(statement: "MATCH (c:Centre {id:$id}) RETURN c")
  centreDropdown(centreName: String): [Centre]
    @cypher(
      statement: "MATCH (c:Centre) WHERE toLower(c.name) CONTAINS toLower($centreName) RETURN c"
    )
  centreBacentaList(id: ID): [Bacenta]
    @cypher(
      statement: """
      MATCH (b:Bacenta)
      WHERE (:Centre {id:$id})-[:HAS_BACENTA]->(b)
      RETURN b
      """
    )
  centreBacentaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Centre {id:$id})-[:HAS_BACENTA]->(cen:Bacenta) RETURN COUNT(cen)"
    )
  centreSontaCount(id: ID): Int!
    @cypher(
      statement: "MATCH (s:Sonta)<-[:HAS_MINISTRY]-(:Centre {name:$centre}) RETURN COUNT(s)"
    )
  centreMemberCount(id: ID): Int!
    @cypher(
      statement: "MATCH (:Centre {id:$id})-[:HAS_BACENTA]->(c:Bacenta)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(DISTINCT m)"
    )
  centreMemberList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (:Centre {id: $id})-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)
      RETURN m
      """
    )

  #At the Bacenta Level
  displayBacenta(id: ID): Bacenta
    @cypher(statement: "MATCH (c:Bacenta{id:$id}) RETURN c")
  bacentaMemberCount(id: ID): Int
    @cypher(
      statement: "MATCH (c:Bacenta{id:$id}) MATCH (c)<-[:BELONGS_TO]-(m:Member) RETURN COUNT(DISTINCT m)"
    )
  bacentaMemberList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (:Bacenta {id:$id})<-[:BELONGS_TO]-(m:Member)
      RETURN m
      """
    )
  bacentaDropdown(bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (c:Bacenta) WHERE toLower(c.name) CONTAINS toLower($bacentaName) RETURN c"
    )

  #At the Ministry Level
  displayMinistry(id: ID): Ministry
    @cypher(statement: "MATCH (m:Ministry {id: $id}) RETURN m")
  sontaTownList(bishopId: ID, ministryId: ID): [Town]
    @cypher(
      statement: """
      MATCH (n:Ministry {id: $ministryId})<-[:BELONGS_TO]-(m:Member)
      MATCH (m)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(e)
      MATCH (e)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
      RETURN DISTINCT e,n
      """
    )

  #At the Sonta Level
  displaySonta(id: ID): Sonta
    @cypher(statement: "MATCH (s:Sonta {id: $id}) RETURN s")
  sontaList: [Sonta] @cypher(statement: "MATCH (s:Sonta) RETURN s")
  townSontaLeader(bishopId: ID): [Member]
    @cypher(
      statement: """
      MATCH (n:Ministry)<-[:BELONGS_TO]-(m:Member)
      MATCH (m)-[:BELONGS_TO]->(:Bacenta)<-[:HAS_BACENTA]-()<-[:HAS_CENTRE]-(e)
      MATCH (e)<-[:HAS_TOWN|HAS_CAMPUS]-(:Member {id: $bishopId})
      MATCH (n)-[:HAS_SONTA]->(s:Sonta {id:$sontaId})<-[:LEADS]-(l:Member)
      WHERE s.name CONTAINS e.name
         RETURN DISTINCT l
      """
    )
  sontaMemberList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (s:Sonta {id: $id})
      MATCH (s)<-[:HAS_SONTA]-()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)
      RETURN m
      """
    )
  sontaMemberCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (s:Sonta {id: $id})
      MATCH (s)<-[:HAS_SONTA]-()-[:HAS_CENTRE]->()-[:HAS_BACENTA]->()<-[:BELONGS_TO]-(m:Member)
      RETURN COUNT(m)
      """
    )
  sontaBasontaLeaderList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (s:Sonta {id: $id})
      MATCH (b:Basonta)<-[:HAS_BASONTA]-(s)
      MATCH (b)<-[:LEADS]-(m)
      RETURN m
      """
    )

  #Members
  # Display Member basecd on ID
  displayMember(id: ID): Member
    @cypher(statement: "MATCH (m:Member {id:$id}) RETURN m")
  memberByEmail(email: String): Member
    @cypher(statement: "MATCH (m:Member {email:$email}) RETURN m")

  #Fuzzy Search
  globalMemberSearch(searchKey: String!): [Member]
    @cypher(
      statement: """
      MATCH (m:Member)
      WHERE toLower(m.firstName) = toLower($searchKey)
      OR toLower(m.lastName) = toLower($searchKey)
      OR toLower(m.firstName) STARTS WITH toLower($searchKey)
      OR toLower(m.lastName) STARTS WITH toLower($searchKey)
      OR toLower(m.firstName) CONTAINS toLower($searchKey)
      OR toLower(m.lastName) CONTAINS toLower($searchKey)
      OR toLower(m.firstName+ " " + m.lastName) CONTAINS toLower($searchKey)
      RETURN m
      """
    )
  globalBacentaSearch(searchKey: String!): [Bacenta]
    @cypher(
      statement: """
      MATCH (b:Bacenta)
      WHERE toLower(b.name) STARTS WITH toLower($searchKey)
      OR toLower(b.name) CONTAINS toLower($searchKey)
      RETURN b
      """
    )
  globalCentreSearch(searchKey: String!): [Centre]
    @cypher(
      statement: """
      MATCH (c:Centre)
      WHERE toLower(c.name) STARTS WITH toLower($searchKey)
      OR toLower(c.name) CONTAINS toLower($searchKey)
      RETURN c
      """
    )
  globalCampusSearch(searchKey: String!): [Campus]
    @cypher(
      statement: """
      MATCH (c:Campus)
      WHERE toLower(c.name) STARTS WITH toLower($searchKey)
      OR toLower(c.name) CONTAINS toLower($searchKey)
      RETURN c
      """
    )
  globalSontaSearch(searchKey: String!): [Sonta]
    @cypher(
      statement: """
      MATCH (c:Sonta)
      WHERE toLower(c.name) STARTS WITH toLower($searchKey)
      OR toLower(c.name) CONTAINS toLower($searchKey)
      RETURN c
      """
    )
  globalTownSearch(searchKey: String!): [Town]
    @cypher(
      statement: """
      MATCH (c:Town)
      WHERE toLower(c.name) STARTS WITH toLower($searchKey)
      OR toLower(c.name) CONTAINS toLower($searchKey)
      RETURN c
      """
    )
  occupationList(searchKey: String!): [Occupation]
    @cypher(
      statement: "MATCH (o:Occupation) WHERE toLower(o.occupation) CONTAINS toLower($searchKey) RETURN o"
    )
}

#Mutation Definitions
type Mutation {
  #CREATE OPERATIONS
  # Add Member to the Database
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    dob: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String!
    ministry: String
    pictureUrl: String!
  ): Member
    @cypher(
      statement: """
      CREATE (m:Member {whatsappNumber:$whatsappNumber})
      SET
      	m.id = apoc.create.uuid(),
      	m.firstName = $firstName,
      	m.middleName = $middleName,
      	m.lastName = $lastName,
      	m.email = $email,
      	m.phoneNumber = $phoneNumber,
      	m.pictureUrl = $pictureUrl
      CREATE (log:HistoryLog)<-[:HAS_HISTORY]-(b)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = time(),
        log.historyRecord = $firstName + $lastName+' was registered on '+toString(date())
      MERGE (t:TimeGraph {date: date()})
      	  MERGE (log)-[:RECORDED_ON]->(t)
      WITH m
      MATCH (ms:MaritalStatus {status:$maritalStatus})
      MATCH (g:Gender {gender: $gender})

         MERGE (m)-[:HAS_MARITAL_STATUS]-> (ms)
      MERGE (m)-[:HAS_GENDER]-> (g)

      WITH m
         CALL {
         	WITH m
         	WITH m  WHERE $dob IS NOT NULL
         	MERGE (t:TimeGraph {date: date($dob)})
      	  MERGE (m)-[:WAS_BORN_ON]->(t)
         	RETURN count(m)
         	}

      WITH m
         CALL {
         	WITH m
         	WITH m  WHERE $occupation IS NOT NULL
         	MERGE (o:Occupation {occupation:$occupation})
      	MERGE (m)-[:HAS_OCCUPATION]-> (o)
         	RETURN count(m)
         	}
      WITH m
      CALL {
         	WITH m
         	WITH m  WHERE $bacenta IS NOT NULL
         	MATCH (c:Bacenta {id: $bacenta})
      	MERGE (m)-[:BELONGS_TO]-> (c)
         	RETURN count(m)
         	}
      WITH m
      CALL {
         	WITH m
         	WITH m  WHERE $ministry IS NOT NULL
         	MATCH (s:Ministry {id:$ministry})
      	MERGE (m)-[:BELONGS_TO]-> (s)
         	RETURN count(m)
         	}

      RETURN m
      """
    )

  CreateTown(
    townName: String
    lWhatsappNumber: String
    id: ID
    centres: [ID]
  ): Town
    @cypher(
      statement: """
      CREATE (t:Town {name:$townName})
         	SET
      	t.id = apoc.create.uuid()
       CREATE (log:HistoryLog)<-[:HAS_HISTORY]-(b)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = time(),
        log.historyRecord = $townName +' Church was started'
      MERGE (t:TimeGraph {date: date()})
      	  MERGE (log)-[:RECORDED_ON]->(t)
      WITH t
      MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
      MERGE (m)-[:LEADS]->(t)
      MERGE (a:Member {id: $id})
      MERGE (a)-[:HAS_TOWN]->(t)

      WITH t
         CALL {
         	WITH t
         	WITH t  WHERE $centres IS NOT NULL
         	UNWIND $centres AS x
             MATCH (c:Centre {id:x})
             OPTIONAL MATCH (t1)-[r:HAS_CENTRE]->(c)
             DELETE r
             MERGE (t)-[:HAS_CENTRE]->(c)
         	RETURN count(t)
         	}

      RETURN t
      """
    )
  CreateCampus(
    campusName: String
    lWhatsappNumber: String
    id: ID
    centres: [ID]
  ): Campus
    @cypher(
      statement: """
      CREATE (t:Campus {name:$campusName})
         	SET
      	t.id = apoc.create.uuid()
       CREATE (log:HistoryLog )<-[:HAS_HISTORY]-(b)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = time(),
        log.historyRecord = $campusName +' Church was started'
      MERGE (t:TimeGraph {date: date(date())})
      	  MERGE (log)-[:RECORDED_ON]->(t)
      WITH t
      MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
      MERGE (m)-[:LEADS]->(t)
      MERGE (a:Member {id: $id})
      MERGE (a)-[:HAS_CAMPUS]->(t)

      WITH t
         CALL {
         	WITH t
         	WITH t  WHERE $centres IS NOT NULL
         	UNWIND $centres AS x
             MATCH (c:Centre {id:x})
             OPTIONAL MATCH (t1)-[r:HAS_CENTRE]->(c)
             DELETE r
             MERGE (t)-[:HAS_CENTRE]->(c)
         	RETURN count(t)
         	}

      RETURN t
      """
    )
  CreateCentre(
    centreName: String
    lWhatsappNumber: String
    townCampusId: ID
    bacentas: [ID]
  ): Centre
    @cypher(
      statement: """
      CREATE (c:Centre {name:$centreName})
         	SET
      	c.id = apoc.create.uuid()
      CREATE (log:HistoryLog {created_at:date()})<-[:HAS_HISTORY]-(b)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = time(),
        log.historyRecord = $centreName +' Centre was started'
      MERGE (t:TimeGraph {date: date()})
      	  MERGE (log)-[:RECORDED_ON]->(t)
      WITH c
      MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
      MATCH (t {id:$townCampusId})-[:HAS_TOWN|:HAS_CAMPUS]-()
      MERGE (t)-[:HAS_CENTRE]->(c)
      MERGE (m)-[:LEADS]->(c)


      WITH c
         CALL {
             WITH c
             WITH c  WHERE $bacentas IS NOT NULL
             UNWIND $bacentas AS x
             MATCH (b:Bacenta {id:x})
             OPTIONAL MATCH (c1)-[r:HAS_BACENTA]->(b)
             DELETE r
             MERGE (c)-[:HAS_BACENTA]->(b)
             RETURN count(c)
             }

      RETURN c
      """
    )
  CreateBacenta(
    bacentaName: String!
    lWhatsappNumber: String
    centreId: ID
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @cypher(
      statement: """
      CREATE (b:Bacenta {name:$bacentaName,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	b.id = apoc.create.uuid()

      WITH b
      MATCH (c:Centre {id: $centreId})
      MERGE (md:ServiceDay {day: $meetingDay})
      MERGE (c)-[:HAS_BACENTA]->(b)
      MERGE (b)-[:MEETS_ON_DAY]->(md)


      WITH b
        CALL {
         	WITH b
          WITH b WHERE $lWhatsappNumber IS NOT NULL
          MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
          CREATE (log:HistoryLog:ServiceLog)
           SET
            log.id = apoc.create.uuid(),
            log.timeStamp = time(),
            log.historyRecord = m.firstName + ' ' +m.lastName + ' started ' + $bacentaName +' Bacenta'
          MERGE (t:TimeGraph {date: date()})
      	    MERGE (log)-[:RECORDED_ON]->(t)
            MERGE (log)<-[:HAS_HISTORY]-(m)
            MERGE (log)<-[r:HAS_HISTORY]-(b)
          MERGE (m)-[:LEADS]->(b)
            SET r.pointer = true
         	RETURN count(b)
         	}

         RETURN b
      """
    )

  #UPDATE OPERATIONS
  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    dob: String
    maritalStatus: String!
    gender: String!
    occupation: String
    bacenta: String
    ministry: String
    pictureUrl: String!
  ): Member
    @cypher(
      statement: """
      MATCH (m:Member {id:$id})
      SET
      	m.firstName = $firstName,
      	m.middleName = $middleName,
      	m.lastName = $lastName,
      	m.email = $email,
      	m.phoneNumber = $phoneNumber,
      	m.pictureUrl = $pictureUrl

      WITH m

      MATCH (g:Gender {gender: $gender})
      MERGE (m)-[:HAS_GENDER]-> (g)


      WITH m
         CALL {
         	WITH m
         	WITH m  WHERE $dob IS NOT NULL
         	MERGE (t:TimeGraph {date: date($dob)})
      	WITH m,t
      	OPTIONAL MATCH (m)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (m)-[:WAS_BORN_ON]->(t)
         	RETURN count(m)
         	}

      WITH m
         CALL {
         	WITH m
         	WITH m  WHERE $maritalStatus IS NOT NULL
         	MATCH (ms:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (m)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (m)-[:HAS_MARITAL_STATUS]-> (ms)
         	RETURN count(m)
         	}

         WITH m
         CALL {
         	WITH m
         	WITH m  WHERE $occupation IS NOT NULL
      	MATCH (m)-[r1:HAS_OCCUPATION]-> ()
         	MERGE (o:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (m)-[:HAS_OCCUPATION]-> (o)
         	RETURN count(m)
         	}
      WITH m
      CALL {
         	WITH m
         	WITH m  WHERE $bacenta IS NOT NULL
         	MATCH (c:Bacenta {id: $bacenta})
      	OPTIONAL MATCH (m)-[r1:BELONGS_TO]-> (:Bacenta)
      	DELETE r1
      	MERGE (m)-[:BELONGS_TO]-> (c)
         	RETURN count(m)
         	}
      WITH m
      CALL {
         	WITH m
         	WITH m  WHERE $ministry IS NOT NULL
         	MATCH (s:Ministry {id:$ministry})
      	OPTIONAL MATCH (m)-[r1:BELONGS_TO]-> (:Ministry)
      	DELETE r1
      	MERGE (m)-[:BELONGS_TO]-> (s)
         	RETURN count(m)
         	}

      RETURN m
      """
    )

  UpdateTown(
    townId: ID!
    townName: String
    lWhatsappNumber: String
    bishopId: ID
  ): Town
    @cypher(
      statement: """
      MATCH (t:Town {id: $townId})
      	SET t.name = $townName

      WITH t
         CALL {
        WITH t
          MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
          OPTIONAL MATCH (t)<-[r:LEADS]-()
          DELETE r
          MERGE (m)-[:LEADS]->(t)
        RETURN count(t)
         	}

      WITH t
         CALL {
         	WITH t
          MATCH (b:Member {id: $bishopId})
          OPTIONAL MATCH (t)<-[r:HAS_TOWN]-()
          DELETE r
          MERGE (b)-[:HAS_TOWN]->(t)
         	RETURN count(t)
         	}

      RETURN t
      """
    )
  UpdateCampus(
    campusId: ID
    campusName: String
    lWhatsappNumber: String
    bishopId: ID
    centres: [ID]
  ): Campus
    @cypher(
      statement: """
      MATCH (t:Campus {id: $campusId})
      	SET t.name = $campusName

      WITH t
         CALL {
         	WITH t

             MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
             OPTIONAL MATCH (t)<-[r:LEADS]-()
             DELETE r
             MERGE (m)-[:LEADS]->(t)
         	RETURN count(t)
         	}

      WITH t
         CALL {
         	WITH t

             MATCH (b:Member {id: $bishopId})
             OPTIONAL MATCH (t)<-[r:HAS_CAMPUS]-()
             DELETE r
             MERGE (b)-[:HAS_CAMPUS]->(t)
         	RETURN count(t)
         	}

      RETURN t
      """
    )
  UpdateCentre(
    centreId: ID
    centreName: String
    lWhatsappNumber: String
    campusTownID: ID
  ): Centre
    @cypher(
      statement: """
      MATCH (c:Centre {id: $centreId})
      	SET c.name = $centreName

      WITH c
         CALL {
         	WITH c

            MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
            OPTIONAL MATCH (c)<-[r:LEADS]-()
            DELETE r
            MERGE (m)-[:LEADS]->(c)
         	RETURN count(c)
         	}

      WITH c
         CALL {
         	WITH c
      		OPTIONAL MATCH (b{id: $campusTownID})

            OPTIONAL MATCH (c)<-[r:HAS_CENTRE]-()
            DELETE r
            MERGE (b)-[:HAS_CENTRE]->(c)
         	RETURN count(c)
         	}

      RETURN c
      """
    )
  UpdateBacenta(
    id: ID
    name: String
    meetingDay: String
    lWhatsappNumber: String
    venueLongitude: Float
    venueLatitude: Float
  ): Bacenta
    @cypher(
      statement: """
               MATCH (b:Bacenta {id: $id})
               	SET b.name = $name
              	SET b.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

              WITH b
                    CALL {
                     	WITH b
                      WITH b WHERE $lWhatsappNumber IS NOT NULL
                      MATCH (m:Member {whatsappNumber: $lWhatsappNumber})
                      OPTIONAL MATCH (b)<-[r:LEADS]-()
                      DELETE r
                      MERGE (m)-[:LEADS]->(b)
                     	RETURN count(b)
                     	}
               WITH b
                    CALL {
                     	WITH b
                      WITH b WHERE $meetingDay IS NOT NULL
                      MATCH (md:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (b)<-[r:MEETS_ON_DAY]-()
                      DELETE r
                      MERGE (b)-[:MEETS_ON_DAY]->(md)
                     	RETURN count(b)
                     	}

      RETURN b
      """
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String
    oldLeaderId: ID
    leaderId: ID
    oldCentreId: ID
    newCentreId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (b:Bacenta {id: $bacentaId})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = time()
       MERGE (t:TimeGraph {date: date()})
       MERGE (b)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(t)

       WITH log,b
       CALL{
         WITH log
         WITH log WHERE $leaderId IS NOT NULL
      OPTIONAL MATCH (oldl:Member {id: $oldLeaderId})
       MATCH (l:Member {id: $leaderId})
         SET log :ServiceLog
         WITH log, l, oldl
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.pointer = false
         WITH log,l, oldl
       CREATE (oldl)-[:HAS_HISTORY]->(log)
       CREATE (l)-[r:HAS_HISTORY]->(log)
          SET r.pointer = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,b
       CALL{
         WITH log
         WITH log WHERE $oldCentreId IS NOT NULL
         MATCH (c:Centre {id: $oldCentreId})
         MERGE (c)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,b
       CALL{
         WITH log
         WITH log WHERE $newCentreId IS NOT NULL
         MATCH (c:Centre {id: $newCentreId})
         MERGE (c)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN b
      """
    )
  LogCentreHistory(
    centreId: ID!
    historyRecord: String
    leaderId: ID
    oldLeaderId: ID
    newCampusTownId: ID
    oldCampusTownId: ID
  ): Centre
    @cypher(
      statement: """
       MATCH  (c:Centre {id: $centreId})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = time()
       MERGE (t:TimeGraph {date: date()})
       MERGE (c)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(t)

       WITH log,c
       CALL{
         WITH log
         WITH log WHERE $leaderId IS NOT NULL
       MATCH (l:Member {id: $leaderId})
      OPTIONAL MATCH (oldl:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, l,oldl
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.pointer = false
         WITH log,l,oldl
       CREATE (oldl)-[:HAS_HISTORY]->(log)
       CREATE (l)-[r:HAS_HISTORY]->(log)
          SET r.pointer = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,c
       CALL {
         WITH log
         WITH log WHERE $oldCampusTownId IS NOT NULL
         MATCH (t {id: $oldCampusTownId}) WHERE t:Town OR t:Campus
         MERGE (t)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,c
       CALL {
         WITH log
         WITH log WHERE $newCampusTownId IS NOT NULL
         OPTIONAL MATCH (t:Town {id: $newCampusTownId})
          MATCH (t {id: $oldCampusTownId}) WHERE t:Town OR t:Campus
         MERGE (t)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN c
      """
    )
  LogTownHistory(
    townId: ID!
    historyRecord: String
    leaderId: ID
    oldLeaderId: ID
    newBishopId: ID
    oldBishopId: ID
  ): Town
    @cypher(
      statement: """
       MATCH  (c:Town {id: $townId})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = time()
       MERGE (t:TimeGraph {date: date()})
       MERGE (c)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(t)

       WITH log,c
       CALL{
         WITH log
         WITH log WHERE $leaderId IS NOT NULL
       MATCH (l:Member {id: $leaderId})
        OPTIONAL MATCH (oldl:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, l,oldl
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.pointer = false
         WITH log,l,oldl
       CREATE (oldl)-[:HAS_HISTORY]->(log)
       CREATE (l)-[r:HAS_HISTORY]->(log)
          SET r.pointer = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,c
       CALL {
         WITH log
         WITH log WHERE $oldBishopId IS NOT NULL
         MATCH (t:Member {id: $oldBishopId})
         MERGE (t)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,c
       CALL {
         WITH log
         WITH log WHERE $newBishopId IS NOT NULL
         MATCH (t:Member {id: $newBishopId})
         MERGE (t)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN c
      """
    )
}

#DELETE OPERATIONS
