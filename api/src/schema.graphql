type Member {
  id: ID!
  auth_id: String
  firstName: String #@search
  middleName: String
  lastName: String
  fullName: String @ignore
  email: String
  phoneNumber: String
  whatsappNumber: String
  pictureUrl: String
  gender: Gender @relationship(type: "HAS_GENDER", direction: OUT)
  maritalStatus: MaritalStatus
    @relationship(type: "HAS_MARITAL_STATUS", direction: OUT)
  dob: TimeGraph @relationship(type: "WAS_BORN_ON", direction: OUT)
  title: [Title]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: OUT)
  ministry: Ministry @relationship(type: "BELONGS_TO", direction: OUT)
  occupation: Occupation @relationship(type: "HAS_OCCUPATION", direction: OUT)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)-[:BELONGS_TO]->(:Fellowship)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  # Church Details
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..6]->(:Fellowship)-[:BELONGS_TO]-(members)
      RETURN DISTINCT members
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..6]->(:Fellowship)-[:BELONGS_TO]-(members)
      RETURN COUNT(DISTINCT members)
      """
    )
  basontaMembers: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..6]->(:Fellowship)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN DISTINCT members
      """
    )
  basontaMembershipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR*1..6]->(:Fellowship)-[:BELONGS_TO]-(members)
      MATCH (members)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT members)
      """
    )
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  loggedHistory: [HistoryLog] @relationship(type: "LOGGED_BY", direction: IN)
  fellowship: Fellowship @relationship(type: "BELONGS_TO", direction: OUT)
  leadsFellowship: [Fellowship] @relationship(type: "LEADS", direction: OUT)
  leadsFellowshipCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(fellowships:Fellowship)
      RETURN COUNT(fellowships)
      """
    )
  leadsBacenta: [Bacenta] @relationship(type: "LEADS", direction: OUT)
  leadsBacentaCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS]->(bacentas:Bacenta)
      RETURN COUNT(bacentas)
      """
    )
  leadsMinistry: [Ministry] @relationship(type: "LEADS", direction: OUT)
  leadsSonta: [Sonta] @relationship(type: "LEADS", direction: OUT)
  leadsBasonta: [Basonta] @relationship(type: "LEADS", direction: OUT)
  leadsConstituency: [Constituency] @relationship(type: "LEADS", direction: OUT)
  leadsConstituencyCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(constituency:Constituency)
      RETURN COUNT(DISTINCT constituency)
      """
    )
  leadsCouncil: [Council] @relationship(type: "LEADS", direction: OUT)
  leadsCouncilCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR]->(council:Council)
      RETURN COUNT(DISTINCT council)
      """
    )
  leadsStream: [Stream] @relationship(type: "LEADS", direction: OUT)
  leadsStreamCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|IS_ADMIN_FOR]->(stream:Stream)
      RETURN COUNT(DISTINCT stream)
      """
    )
  leadsGatheringService: [GatheringService]
    @relationship(type: "LEADS", direction: OUT)
  leadsGatheringServiceCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:LEADS|HAS|IS_ADMIN_FOR]->(gatheringService:GatheringService)
      RETURN COUNT(DISTINCT gatheringService)
      """
    )
  isAdminForGatheringService: [GatheringService]
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForCouncil: [Council]
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForStream: [Stream] @relationship(type: "IS_ADMIN_FOR", direction: OUT)
  isAdminForConstituency: [Constituency]
    @relationship(type: "IS_ADMIN_FOR", direction: OUT)

  #OTHER WORKS
  was_treasurer_for: [ServiceRecord]!
    @relationship(type: "WAS_TREASURER_FOR", direction: OUT)
}

extend type Member @auth(rules: [{ isAuthenticated: true }])
extend type Fellowship @auth(rules: [{ isAuthenticated: true }])
extend type Bacenta @auth(rules: [{ isAuthenticated: true }])
extend type Constituency @auth(rules: [{ isAuthenticated: true }])
extend type Council
  @auth(
    rules: [
      { isAuthenticated: true }
      { roles: ["adminGatheringService", "adminStream", "adminCouncil"] }
    ]
  )
extend type Stream
  @auth(
    rules: [
      { isAuthenticated: true }
      { roles: ["adminGatheringService", "adminStream"] }
    ]
  )
extend type GatheringService
  @auth(
    rules: [{ isAuthenticated: true }, { roles: ["adminGatheringService"] }]
  )
extend type Sonta @auth(rules: [{ isAuthenticated: true }])
extend type Ministry @auth(rules: [{ isAuthenticated: true }])

type Gender @auth(rules: [{ isAuthenticated: true }]) {
  gender: String
  members: [Member] @relationship(type: "HAS_GENDER", direction: IN)
}

type MaritalStatus @auth(rules: [{ isAuthenticated: true }]) {
  status: String
  members: [Member] @relationship(type: "HAS_MARITAL_STATUS", direction: IN)
}

type Occupation @auth(rules: [{ isAuthenticated: true }]) {
  occupation: String
  members: [Member] @relationship(type: "HAS_OCCUPATION", direction: IN)
}

type Title @auth(rules: [{ isAuthenticated: true }]) {
  title: String! #Pastor, Reverend, Apostle, Bishop (Mother)
  members: [Member]
    @relationship(type: "HAS_TITLE", properties: "HasTitle", direction: IN)
}

interface HasTitle @relationshipProperties {
  date: Date
}

type TimeGraph @auth(rules: [{ isAuthenticated: true }]) {
  date: Date
  memberDo: Member @relationship(type: "WAS_BORN_ON", direction: IN)
  # titleAppointmentDate: Member @relationship(type: "APPOINTED_ON", direction: IN)
  leaderHistoryStartDate: Member
    @relationship(type: "LEADER_STARTED_ON", direction: OUT)
  leaderHistoryEndDate: TimeGraph
    @relationship(type: "LEADER_ENDED_ON", direction: OUT)
  historyDate: Member @relationship(type: "RECORDED_ON", direction: OUT)
  serviceDate: [ServiceRecord]
    @relationship(type: "SERVICE_HELD_ON", direction: IN)
}

type ServiceRecord @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  attendance: Int
  income: Float
  foreignCurrency: String
  servicePicture: String
  treasurerSelfie: String
  bankingSlip: String
  treasurers: [Member]! @relationship(type: "WAS_TREASURER_FOR", direction: IN)
  serviceLog: ServiceLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type NoService @auth(rules: [{ isAuthenticated: true }]) {
  id: ID!
  created_at: Date
  created_by: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceDate: TimeGraph @relationship(type: "SERVICE_HELD_ON", direction: OUT)
  week: Int
    @cypher(
      statement: """
      MATCH (this)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN date(date.date).week
      """
    )
  serviceLog: ServiceLog @relationship(type: "HAS_RECORD", direction: IN)
  noServiceReason: String
}

type ServiceLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  serviceRecords: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  # bacentaFellowshipRecords(bacentaId: ID!): [BacentaFellowshipServiceRecords]
  constituency: [Constituency] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

type ComponentServiceAggregate {
  week: Int!
  attendance: Int!
  income: Float!
}

type HistoryLog @auth(rules: [{ isAuthenticated: true }]) {
  id: ID @id
  timeStamp: DateTime
  historyRecord: String #leader was transferred to
  created_at: TimeGraph @relationship(type: "RECORDED_ON", direction: OUT)
  loggedBy: Member @relationship(type: "LOGGED_BY", direction: OUT)
  leaders: [Member] @relationship(type: "HAS_HISTORY", direction: IN)
  fellowship: [Fellowship] @relationship(type: "HAS_HISTORY", direction: IN)
  bacenta: [Bacenta] @relationship(type: "HAS_HISTORY", direction: IN)
  constituency: [Constituency] @relationship(type: "HAS_HISTORY", direction: IN)
  sonta: [Sonta] @relationship(type: "HAS_HISTORY", direction: IN)
}

type GatheringService {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  streams: [Stream] @relationship(type: "HAS", direction: OUT)
  councils: [Council]
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(councils:Council) RETURN councils"
    )
  constituencies: [Constituency]
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(constituencies:Constituency) RETURN constituencies"
    )
  bacentas: [Bacenta]
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacenta:Bacenta) RETURN bacenta"
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(:Fellowship)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  streamCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(stream:Stream) RETURN COUNT(stream)"
    )
  councilCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(council:Council) RETURN COUNT(council)"
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(constituency:Constituency) RETURN COUNT(constituency)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(fellowships:Fellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  bacentaSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL AND record.attendance IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}
      RETURN DISTINCT fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}

      RETURN COUNT(DISTINCT fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*5]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Stream {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  councils: [Council] @relationship(type: "HAS", direction: OUT)
  gatheringService: GatheringService @relationship(type: "HAS", direction: IN)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this:Stream)
      RETURN DISTINCT toLower(this.name)
      """
    )
  constituencies: [Constituency]
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(constituencies:Constituency) RETURN constituencies"
    )
  bacentas: [Bacenta]
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacenta:Bacenta) RETURN bacenta"
    )

  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(:Fellowship)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(constituency:Constituency) RETURN COUNT(constituency)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  bacentaSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(fellowships:Fellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL AND record.attendance IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}
      RETURN DISTINCT fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}

      RETURN COUNT(DISTINCT fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*4]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Council {
  id: ID @id
  name: String!
  leader: Member @relationship(type: "LEADS", direction: IN)
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  stream: Stream @relationship(type: "HAS", direction: IN)
  bacentas: [Bacenta]
    @cypher(
      statement: "MATCH (this)-[:HAS*1..2]->(bacenta:Bacenta) RETURN bacenta"
    )
  constituencies: [Constituency] @relationship(type: "HAS", direction: OUT)
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  pastorCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(:Fellowship)<-[:BELONGS_TO]-(pastors:Member)-[:HAS_TITLE]->(:Title)
      RETURN COUNT(DISTINCT pastors)
      """
    )
  constituencyCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]->(constituency:Constituency) RETURN COUNT(constituency)"
    )
  bacentaCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*2]->(bacentas:Bacenta) RETURN COUNT(DISTINCT bacentas)"
    )
  bacentaSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:Fellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship) RETURN COUNT(DISTINCT fellowships)"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL AND record.attendance IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}
      RETURN DISTINCT fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}

      RETURN COUNT(DISTINCT fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*3]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Constituency {
  id: ID @id
  name: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  fellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:Fellowship) RETURN COUNT(fellowship)"
    )
  fellowshipSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
    )
  bacentaSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($key)
      RETURN DISTINCT bacenta LIMIT $limit
      """
    )
  activeFellowshipCount: Int
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Bacenta)-[:HAS]->(fellowship:ActiveFellowship) RETURN COUNT(fellowship)"
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  sontas: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  bacentas: [Bacenta] @relationship(type: "HAS", direction: OUT)

  council: Council @relationship(type: "HAS", direction: IN)
  bishop: Member
    @cypher(
      statement: "MATCH (this)-[:HAS]-(:Council)-[:LEADS]-(bishop:Member) RETURN bishop"
    )
  admin: Member @relationship(type: "IS_ADMIN_FOR", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceRecord: [ServiceRecord]
    @relationship(type: "HAS_RECORD", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(records:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN records ORDER BY date.date DESC LIMIT $limit
      """
    )
  servicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN fellowships
      """
    )
  servicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week
        }
      RETURN COUNT(fellowships)
      """
    )
  cancelledServicesThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN fellowships
      """
    )
  cancelledServicesThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  formDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
      WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}
      RETURN DISTINCT fellowships
      """
    )
  formDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships:ActiveFellowship)
           WHERE EXISTS {
        MATCH (fellowships)-[:MEETS_ON]->(day:ServiceDay)
        WHERE day.dayNumber < date().dayOfWeek OR  time() > time('20:30')
         }
        AND NOT EXISTS {MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date.date.week = date().week}
      RETURN COUNT(DISTINCT fellowships)
      """
    )
  bankingDefaultersThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN fellowships
      """
    )
  bankingDefaultersThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NULL
        }
      RETURN COUNT(fellowships)
      """
    )
  bankedThisWeek: [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN fellowships
      """
    )
  bankedThisWeekCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS*2]->(fellowships) WHERE fellowships:ActiveFellowship OR fellowships:ClosedFellowship
      MATCH (fellowships) WHERE EXISTS {
        MATCH (fellowships)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(record:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph ) WHERE date(date.date).week = date().week AND record.noServiceReason IS NULL AND record.bankingSlip IS NOT NULL
        }
      RETURN COUNT(fellowships)
      """
    )

  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

type Bacenta {
  id: ID @id
  name: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  members: [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN DISTINCT members
      """
    )
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  fellowships: [Fellowship] @relationship(type: "HAS", direction: OUT)
  fellowshipSearch(key: String!, limit: Int!): [Fellowship]
    @cypher(
      statement: """
      MATCH (this)-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) CONTAINS toLower($key)
      RETURN DISTINCT fellowship LIMIT $limit
      """
    )
  basontas: Basonta @relationship(type: "HAS_BASONTA", direction: OUT)
  constituency: Constituency @relationship(type: "HAS", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*2]-(council:Council)
      RETURN council
      """
    )
  componentServiceAggregate: [ComponentServiceAggregate] @ignore
}

# Shared Units: Fellowship, Fellowship, Sonta
type Fellowship {
  id: ID @id
  bankingCode: Int
  name: String
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
}
type ClosedFellowship {
  id: ID @id
  bankingCode: Int
  name: String
  location: Point
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  bacenta: Bacenta @relationship(type: "HAS", direction: IN)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
  memberSearch(key: String!, limit: Int!): [Member]
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      WHERE toLower(members.firstName+ ' ' + members.lastName) CONTAINS toLower($key)
      RETURN DISTINCT members LIMIT $limit
      """
    )
  memberCount: Int
    @cypher(
      statement: """
      MATCH (this)<-[:BELONGS_TO]-(members:Member)
      RETURN COUNT(DISTINCT members)
      """
    )
  meetingDay: ServiceDay @relationship(type: "MEETS_ON", direction: OUT)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  services(limit: Int!): [ServiceRecord]
    @cypher(
      statement: """
      MATCH (this)-[:HAS_HISTORY]->(:ServiceLog)-[:HAS_RECORD]->(services:ServiceRecord)-[:SERVICE_HELD_ON]->(date:TimeGraph)
      RETURN services ORDER BY date.date DESC LIMIT $limit
      """
    )
  labels: [String]
    @cypher(
      statement: """
      MATCH (this)
      RETURN labels(this)
      """
    )
  council: Council
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*3]-(council:Council)
      RETURN council
      """
    )
}

type ServiceDay @auth(rules: [{ isAuthenticated: true }]) {
  day: String!
  dayNumber: Int
  fellowship: Fellowship @relationship(type: "MEETS_ON", direction: IN)
}

type Ministry {
  id: ID @id
  name: String
  sonta: [Sonta] @relationship(type: "HAS_SONTA", direction: OUT)
  leader: Member @relationship(type: "LEADS", direction: IN)
  members: [Member] @relationship(type: "BELONGS_TO", direction: IN)
}

type Sonta {
  id: ID @id
  name: String
  stream_name: String
    @cypher(
      statement: """
      MATCH (this)<-[:HAS*4]-(stream:Stream)
      RETURN DISTINCT toLower(stream.name)
      """
    )
  leader: Member @relationship(type: "LEADS", direction: IN)
  basonta: [Basonta] @relationship(type: "HAS_BASONTA", direction: OUT)
  ministry: Ministry @relationship(type: "HAS_SONTA", direction: IN)
  history: [HistoryLog] @relationship(type: "HAS_HISTORY", direction: OUT)
  constituency: Constituency @relationship(type: "HAS_SONTA", direction: IN)
  serviceLogs: [ServiceLog] @relationship(type: "HAS_HISTORY", direction: OUT)
}
type Basonta {
  id: ID @id
  name: String
  leader: Member @relationship(type: "LEADS", direction: IN)
  bacenta: Bacenta @relationship(type: "HAS_BASONTA", direction: IN)
  sonta: Sonta @relationship(type: "HAS_BASONTA", direction: IN)
}

#Query Definitions
type Query {
  #At the Federal Level

  #At the Episcopal Level

  councilFellowshipDropdown(id: ID!, fellowshipName: String!): [Fellowship]
    @cypher(
      statement: "MATCH (council:Council {id:$id})-[:HAS*3]->(fellowship:Fellowship) WHERE toLower(fellowship.name) CONTAINS toLower($fellowshipName) RETURN DISTINCT fellowship LIMIT 5"
    )
  constituencyDropdown(nameSearch: String!): [Constituency]
    @cypher(
      statement: "MATCH (constituency:Constituency) WHERE toLower(constituency.name) CONTAINS toLower($nameSearch) RETURN DISTINCT constituency LIMIT 5"
    )
  councilDropdown(nameSearch: String!): [Council]
    @cypher(
      statement: "MATCH (council:Council) WHERE toLower(council.name) CONTAINS toLower($nameSearch) RETURN DISTINCT council LIMIT 5"
    )
  bishopsSontaMemberList(id: ID): [Member]!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN member
      """
    )
  bishopSontamembershipCount(id: ID): Int!
    @cypher(
      statement: """
      MATCH (:Member {id: $id})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)-[:BELONGS_TO]->(:Ministry)
      RETURN COUNT(DISTINCT member)
      """
    )
  bishopSontamembershipCountList(bishopId: ID): [Ministry]!
    @cypher(
      statement: """
      MATCH (:Member {id: $bishopId})-[:HAS]->()-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(m:Member)-[:BELONGS_TO]->(ministry:Ministry)
      RETURN ministry, COUNT(DISTINCT member)
      """
    )
  bishopPastorCount(id: ID): Int!
    @cypher(
      statement: "MATCH (title:Title)<-[:HAS_TITLE]-(member:Member)-[:BELONGS_TO]->(:Fellowship)<-[:HAS]-(:Bacenta)-[:HAS]-()-[:HAS]-(:Member {id: $id}) RETURN COUNT( DISTINCT member)"
    )

  councilBacentaDropdown(id: ID!, nameSearch: String!): [Bacenta]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(constituency:Constituency)
      MATCH (constituency)-[:HAS]->(bacenta:Bacenta)
      WHERE toLower(bacenta.name) CONTAINS toLower($nameSearch)
      RETURN bacenta LIMIT 5
      """
    )

  councilMemberDropdown(id: ID!, nameSearch: String!): [Member]
    @cypher(
      statement: """
      MATCH (:Council {id: $id})-[:HAS]->(constituency:Constituency)
      MATCH (constituency)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName+ ' ' + member.lastName) CONTAINS toLower($nameSearch)
      RETURN member LIMIT 5
      """
    )

  #At the Bacenta Level
  bacentaDropdown(bacentaName: String): [Bacenta]
    @cypher(
      statement: "MATCH (bacenta:Bacenta) WHERE toLower(bacenta.name) CONTAINS toLower($bacentaName) RETURN bacenta LIMIT 5"
    )

  fellowshipDropdown(fellowshipName: String): [Fellowship]
    @cypher(
      statement: "MATCH (fellowship:Fellowship) WHERE toLower(fellowship.name) CONTAINS toLower($fellowshipName) RETURN DISTINCT fellowship LIMIT 5"
    )

  sontaBasontaLeaderList(id: ID): [Member]
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $id})
      MATCH (basonta:Basonta)<-[:HAS_BASONTA]-(sonta)
      MATCH (basonta)<-[:LEADS]-(leader)
      RETURN leader
      """
    )

  #Members
  # Display Member based on ID
  currentUser(id: ID): Member
    @cypher(
      statement: "MATCH (member:Member {auth_id: $auth.jwt.sub}) RETURN member"
    )
    @auth(rules: [{ isAuthenticated: true }])

  memberByEmail(email: String!): Member
    @cypher(
      statement: "MATCH (member:Member {email:$email}) RETURN member LIMIT 1"
    )

  #Fuzzy Search
  federalMemberSearch(searchKey: String): [Member]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.middleName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.middleName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      RETURN member LIMIT 5
      """
    )
  councilMemberSearch(searchKey: String, councilId: ID): [Member]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(:Constituency)-[:HAS]->(:Bacenta)-[:HAS]->(:Fellowship)<-[:BELONGS_TO*]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)
      WITH member WHERE member IS NOT NULL
      RETURN DISTINCT(member) LIMIT 5
      """
    )
  constituencyMemberSearch(searchKey: String, constituencyId: ID): [Member]
    @auth(rules: [{ roles: ["adminConstituency"] }])
    @cypher(
      statement: """
      MATCH (constituency:Constituency {id:$constituencyId})
      MATCH (constituency)-[:HAS]->(:Bacenta)-[:HAS]->(fellowship:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  bacentaMemberSearch(searchKey: String, bacentaId: ID): [Member]
    @auth(rules: [{ roles: ["leaderBacenta"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(:Fellowship)<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  fellowshipMemberSearch(searchKey: String, fellowshipId: ID): [Member]
    @auth(rules: [{ roles: ["leaderFellowship"] }])
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id: $fellowshipId})<-[:BELONGS_TO]-(member:Member)
      WHERE toLower(member.firstName) = toLower($searchKey)
      OR toLower(member.lastName) = toLower($searchKey)
      OR toLower(member.firstName) STARTS WITH toLower($searchKey)
      OR toLower(member.lastName) STARTS WITH toLower($searchKey)
      OR toLower(member.firstName + ' ' + member.middleName+ ' '+ member.lastName) CONTAINS toLower($searchKey)

      RETURN member LIMIT 5
      """
    )
  federalFellowshipSearch(searchKey: String): [Fellowship]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  councilFellowshipSearch(searchKey: String, councilId: ID): [Fellowship]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*3]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  constituencyFellowshipSearch(
    searchKey: String
    constituencyId: ID
  ): [Fellowship]
    @auth(rules: [{ roles: ["adminConstituency"] }])
    @cypher(
      statement: """
      MATCH (constituency:Constituency {id:$constituencyId})-[:HAS*2]->(fellowship:Fellowship)

      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  bacentaFellowshipSearch(searchKey: String, bacentaId: ID): [Fellowship]
    @auth(rules: [{ roles: ["leaderBacenta"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})-[:HAS]->(fellowship:Fellowship)
      WHERE toLower(fellowship.name) STARTS WITH toLower($searchKey)
      OR toLower(fellowship.name) CONTAINS toLower($searchKey)
      RETURN DISTINCT fellowship LIMIT 5
      """
    )
  federalBacentaSearch(searchKey: String): [Bacenta]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta)
      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  councilBacentaSearch(searchKey: String, councilId: ID): [Bacenta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS*2]->(bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  constituencyBacentaSearch(
    searchKey: String
    constituencyId: ID
  ): [Fellowship]
    @auth(rules: [{ roles: ["adminConstituency"] }])
    @cypher(
      statement: """
      MATCH (constituency:Constituency {id:$constituencyId})
      MATCH (constituency)-[:HAS]->(bacenta)

      WHERE toLower(bacenta.name) STARTS WITH toLower($searchKey)
      OR toLower(bacenta.name) CONTAINS toLower($searchKey)
      RETURN bacenta LIMIT 5
      """
    )
  federalConstituencySearch(searchKey: String): [Constituency]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (constituency:Constituency)
      WHERE toLower(constituency.name) STARTS WITH toLower($searchKey)
      OR toLower(constituency.name) CONTAINS toLower($searchKey)
      RETURN constituency LIMIT 5
      """
    )
  federalCouncilSearch(searchKey: String): [Council]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (council:Council)
      WHERE toLower(council.name) STARTS WITH toLower($searchKey)
      OR toLower(council.name) CONTAINS toLower($searchKey)
      RETURN council LIMIT 5
      """
    )
  federalStreamSearch(searchKey: String): [Stream]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (stream:Stream)
      WHERE toLower(stream.name) STARTS WITH toLower($searchKey)
      OR toLower(stream.name) CONTAINS toLower($searchKey)
      RETURN stream LIMIT 5
      """
    )
  councilConstituencySearch(searchKey: String, councilId: ID): [Constituency]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(constituency)

      WHERE toLower(constituency.name) STARTS WITH toLower($searchKey)
      OR toLower(constituency.name) CONTAINS toLower($searchKey)
      RETURN constituency LIMIT 5
      """
    )

  federalSontaSearch(searchKey: String): [Sonta]
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      MATCH (sonta:Sonta)
      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  councilSontaSearch(searchKey: String, councilId: ID): [Sonta]
    @auth(rules: [{ roles: ["adminCouncil"] }])
    @cypher(
      statement: """
      MATCH (council:Council {id: $councilId})-[:HAS]->(constituency)
      MATCH (constituency)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )
  constituencySontaSearch(searchKey: String, constituencyId: ID): [Fellowship]
    @auth(rules: [{ roles: ["adminConstituency"] }])
    @cypher(
      statement: """
      MATCH (constituency:Constituency {id:$constituencyId})
      MATCH (constituency)-[:HAS_SONTA]->(sonta)

      WHERE toLower(sonta.name) STARTS WITH toLower($searchKey)
      OR toLower(sonta.name) CONTAINS toLower($searchKey)
      RETURN sonta LIMIT 5
      """
    )

  occupationList(searchKey: String!): [Occupation]
    @cypher(
      statement: "MATCH (occupation:Occupation) WHERE toLower(occupation.occupation) CONTAINS toLower($searchKey) RETURN occupation"
    )
}

#Mutation Definitions
type Mutation {
  #resolver Mutations
  MakeStreamAdmin(adminId: ID!, streamId: ID!): Member
  RemoveStreamAdmin(adminId: ID!, streamId: ID!): Member
  MakeCouncilAdmin(adminId: ID!, councilId: ID!): Member
  RemoveCouncilAdmin(adminId: ID!, councilId: ID!): Member
  MakeConstituencyAdmin(adminId: ID!, constituencyId: ID!): Member
  RemoveConstituencyAdmin(adminId: ID!, constituencyId: ID!): Member
  MakeFellowshipLeader(leaderId: ID!, fellowshipId: ID!): Member
  RemoveFellowshipLeader(leaderId: ID!, fellowshipId: ID!): Member
  MakeBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  RemoveBacentaLeader(leaderId: ID!, bacentaId: ID!): Member
  MakeSontaLeader(leaderId: ID!, sontaId: ID!): Member
  RemoveSontaLeader(leaderId: ID!, sontaId: ID!): Member
  MakeConstituencyLeader(leaderId: ID!, constituencyId: ID!): Member
  RemoveConstituencyLeader(leaderId: ID!, constituencyId: ID!): Member
  MakeCouncilLeader(leaderId: ID!, councilId: ID!): Member
  RemoveCouncilLeader(leaderId: ID!, councilId: ID!): Member
  MakeStreamLeader(leaderId: ID!, streamId: ID!): Member
  RemoveStreamLeader(leaderId: ID!, streamId: ID!): Member
  MakeGatheringServiceLeader(leaderId: ID!, gatheringServiceId: ID!): Member
  RemoveGatheringServiceLeader(leaderId: ID!, gatheringServiceId: ID!): Member

  #CREATE OPERATIONS
  # Add Member to the Database
  CreateMember(
    firstName: String!
    middleName: String
    lastName: String!
    email: String!
    phoneNumber: String!
    whatsappNumber: String!
    dob: String!
    maritalStatus: String!
    gender: String!
    occupation: String
    fellowship: String!
    ministry: String
    pictureUrl: String!
  ): Member

  CreateStream(
    name: String!
    leaderId: ID!
    gatheringServiceId: ID!
    councils: [ID]
  ): Stream
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
      CREATE (stream:Stream {id:apoc.create.uuid(), name:$name})

      WITH stream
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (gatheringService:GatheringService {id: $gatheringServiceId})


       CREATE (log:HistoryLog:ServiceLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $name +' Stream under '+ gatheringService.name+ ' Gathering Service'

      MERGE (gatheringService)-[:HAS]->(stream)
      MERGE (leader)-[:LEADS]->(stream)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (stream)-[:HAS_HISTORY]->(log)

      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH stream, gatheringService
      CALL {
        WITH stream
        WITH stream WHERE $councils <> []
        UNWIND $councils AS councilIds
        MATCH (council:Council {id:councilIds})
        OPTIONAL MATCH (oldStream)-[r:HAS]->(council)
        DELETE r

        MERGE (stream)-[:HAS]->(council)
        RETURN count(stream)
      }

      RETURN stream
      """
    )

  CreateCouncil(
    name: String!
    leaderId: ID!
    streamId: ID!
    constituencies: [ID]
  ): Council
    @auth(rules: [{ roles: ["adminGatheringService", "adminStream"] }])
    @cypher(
      statement: """
       CREATE (council:Council {id:apoc.create.uuid(), name:$name})

      WITH council
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (stream:Stream {id: $streamId})


       CREATE (log:HistoryLog:ServiceLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $name +' Council under '+ stream.name+ ' Stream'

      MERGE (stream)-[:HAS]->(council)
      MERGE (leader)-[:LEADS]->(council)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)

      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH council, stream
      CALL {
        WITH council
        WITH council WHERE $constituencies <> []
        UNWIND $constituencies AS constituencyIds
        MATCH (constituency:Constituency {id:constituencyIds})
        OPTIONAL MATCH (oldCouncil)-[r:HAS]->(constituency)
        DELETE r

        MERGE (council)-[:HAS]->(constituency)
        RETURN count(council)
      }

      RETURN council
      """
    )

  CreateConstituency(
    name: String!
    leaderId: ID!
    councilId: ID!
    bacentas: [ID]
  ): Constituency
    @auth(
      rules: [
        { roles: ["adminGatheringService", "adminStream", "adminCouncil"] }
      ]
    )
    @cypher(
      statement: """
       CREATE (constituency:Constituency {name:$name})
         	SET
      	constituency.id = apoc.create.uuid()
      WITH constituency
      MATCH (leader:Member {id: $leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (council:Council {id: $councilId})

       CREATE (log:HistoryLog)
        SET
        log.id =  apoc.create.uuid(),
        log.timeStamp = datetime(),
        log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + $name +' Constituency under '+ council.name+ ' Council'

      MERGE (council)-[:HAS]->(constituency)
      MERGE (leader)-[:LEADS]->(constituency)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (constituency)-[:HAS_HISTORY]->(log)
      MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      WITH constituency, council
      CALL {
        WITH constituency
        WITH constituency WHERE $bacentas <> []
        UNWIND $bacentas AS bacentaIds
        MATCH (bacenta:Bacenta {id:bacentaIds})
        OPTIONAL MATCH (oldconstituency)-[r:HAS]->(bacenta)
        DELETE r

        MERGE (constituency)-[:HAS]->(bacenta)
        RETURN count(constituency)
      }

      RETURN constituency
      """
    )

  CreateBacenta(
    name: String!
    constituencyId: ID!
    leaderId: ID!
    fellowships: [ID]
  ): Bacenta  #Return constituency and drill down to get bacenta info
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      CREATE (bacenta:Bacenta {name:$name})
         	SET
      	bacenta.id = apoc.create.uuid()
      WITH bacenta
       MATCH (leader:Member {id:$leaderId})
       MATCH (constituency:Constituency {id:$constituencyId})
       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(constituency) AS stream

      CREATE (log:HistoryLog:ServiceLog)
      SET log.id = apoc.create.uuid(),
       log.timeStamp = datetime(),
       log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + bacenta.name +' Bacenta under '+ constituency.name + ' ' + stream

       MERGE (constituency)-[:HAS]->(bacenta)
       MERGE (leader)-[:LEADS]->(bacenta)

       MERGE (date:TimeGraph {date: date()})
       MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (constituency)-[:HAS_HISTORY]->(log)
       MERGE (bacenta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

       WITH bacenta
      CALL {
        WITH bacenta
        WITH bacenta WHERE $fellowships <> []
        UNWIND $fellowships AS fellowshipIds
        MATCH (fellowship:Fellowship {id:fellowshipIds})
        OPTIONAL MATCH (oldBacenta)-[r:HAS]->(fellowship)
        DELETE r

        MERGE (bacenta)-[:HAS]->(fellowship)
        RETURN count(bacenta)
      }

      RETURN bacenta
      """
    )
  CreateSonta(
    ministryId: ID!
    constituencyId: ID!
    leaderId: ID!
  ): Constituency
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      CREATE (sonta:Sonta)
         	SET
      	sonta.id = apoc.create.uuid()
      WITH sonta
       MATCH (ministry:Ministry {id:$ministryId})
       MATCH (leader:Member {id: $leaderId})
       MATCH (constituency:Constituency {id:$constituencyId})

       MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
       UNWIND labels(constituency) AS stream

       CREATE (log:HistoryLog:ServiceLog)
        SET log.id = apoc.create.uuid(),
         log.timeStamp = datetime(),
         log.historyRecord = leader.firstName + ' ' +leader.lastName + ' started ' + sonta.name +' Sonta under '+ constituency.name + ' ' + stream


       SET sonta.name = constituency.name + ' ' + ministry.name

       MERGE (ministry)-[:HAS_SONTA]->(sonta)
       MERGE (constituency)-[:HAS_SONTA]->(sonta)
       MERGE (leader)-[:LEADS]->(sonta)

      MERGE (date:TimeGraph {date: date()})
      MERGE (log)-[:LOGGED_BY]->(currentUser)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (constituency)-[:HAS_HISTORY]->(log)
       MERGE (sonta)-[:HAS_HISTORY]->(log)
       MERGE (leader)-[r:HAS_HISTORY]->(log)
        SET r.current = true

      RETURN constituency
      """
    )
  CreateFellowship(
    name: String!
    bacentaId: ID!
    leaderId: ID!
    meetingDay: String!
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (lastCode:LastBankingCode)
      CREATE (fellowship:Fellowship:ActiveFellowship {name:$name,location: point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})})
         	SET
      	fellowship.id = apoc.create.uuid(),
        fellowship.bankingCode = lastCode.number + 1,
        lastCode.number = fellowship.bankingCode

      WITH fellowship
      MATCH (bacenta:Bacenta {id: $bacentaId})
      MATCH (leader:Member {id:$leaderId})
      MATCH (currentUser:Member {auth_id:$auth.jwt.sub})
      MATCH (meetingDay:ServiceDay {day: $meetingDay})

      MERGE (bacenta)-[:HAS]->(fellowship)
      MERGE (leader)-[r:LEADS]->(fellowship)
      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)
        SET r.current = true

      RETURN fellowship
      """
    )

  #UPDATE OPERATIONS
  UpdateMemberDetails(
    id: ID!
    firstName: String!
    middleName: String
    lastName: String!
    email: String
    phoneNumber: String!
    whatsappNumber: String
    dob: String
    maritalStatus: String!
    gender: String!
    occupation: String
    fellowship: String!
    ministry: String
    pictureUrl: String!
  ): Member
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminCouncil"
            "adminConstituency"
            "leaderFellowship"
            "leaderBacenta"
            "leaderConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (member:Member {id:$id})
      SET
      	member.firstName = $firstName,
      	member.middleName = $middleName,
      	member.lastName = $lastName,
      	member.email = $email,
      	member.phoneNumber = $phoneNumber,
        member.whatsappNumber = $whatsappNumber,
      	member.pictureUrl = $pictureUrl

      WITH member

      MATCH (gender:Gender {gender: $gender})
      MERGE (member)-[:HAS_GENDER]-> (gender)


      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $dob IS NOT NULL
         	MERGE (date:TimeGraph {date: date($dob)})
      	WITH member,date
      	OPTIONAL MATCH (member)-[r1:WAS_BORN_ON]->()
      	DELETE r1
      	MERGE (member)-[:WAS_BORN_ON]->(date)
         	RETURN count(member)
         	}

      WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $maritalStatus IS NOT NULL
         	MATCH (maritalStatus:MaritalStatus {status:$maritalStatus})
      	OPTIONAL MATCH (member)-[r1:HAS_MARITAL_STATUS]->()
      	DELETE r1
      	MERGE (member)-[:HAS_MARITAL_STATUS]-> (maritalStatus)
         	RETURN count(member)
         	}

         WITH member
         CALL {
         	WITH member
         	WITH member  WHERE $occupation IS NOT NULL
      	OPTIONAL MATCH (member)-[r1:HAS_OCCUPATION]-> ()
        MERGE (occupation:Occupation {occupation:$occupation})
      	DELETE r1
      	MERGE (member)-[:HAS_OCCUPATION]-> (occupation)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $fellowship IS NOT NULL
         	MATCH (fellowship:Fellowship {id: $fellowship})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Fellowship)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (fellowship)
         	RETURN count(member)
         	}
      WITH member
      CALL {
         	WITH member
         	WITH member  WHERE $ministry IS NOT NULL
         	MATCH (ministry:Ministry {id:$ministry})
      	OPTIONAL MATCH (member)-[r0:BELONGS_TO]-> (:Ministry)
      	DELETE r0
      	MERGE (member)-[:BELONGS_TO]-> (ministry)
         	RETURN count(member)
         	}

      RETURN member
      """
    )
  UpdateStreamDetails(
    streamId: ID!
    name: String!
    gatheringServiceId: ID!
  ): Stream
    @auth(rules: [{ roles: ["adminGatheringService"] }])
    @cypher(
      statement: """
           MATCH (stream:Stream {id: $streamId})
           	SET stream.name = $name

           WITH stream
              CALL {
              	WITH stream

                  MATCH (gatheringService:GatheringService {id: $gatheringServiceId})
                  OPTIONAL MATCH (stream)<-[r:HAS]-()
                  DELETE r
                  MERGE (gatheringService)-[:HAS]->(stream)
              	RETURN count(stream)
              	}
      MATCH (stream)<-[:LEADS]-(leader:Member)
      RETURN stream
      """
    )
  UpdateCouncilDetails(councilId: ID!, name: String!, streamId: ID!): Council
    @auth(rules: [{ roles: ["adminGatheringService", "adminStream"] }])
    @cypher(
      statement: """
           MATCH (council:Council {id: $councilId})
           	SET council.name = $name

           WITH council
              CALL {
              	WITH council

                  MATCH (stream:Stream {id: $streamId})
                  OPTIONAL MATCH (council)<-[r:HAS]-()
                  DELETE r
                  MERGE (stream)-[:HAS]->(council)
              	RETURN count(council)
              	}
      MATCH (council)<-[:LEADS]-(leader:Member)
      RETURN council
      """
    )

  UpdateConstituencyDetails(
    constituencyId: ID!
    name: String!
    councilId: ID!
  ): Constituency
    @auth(
      rules: [
        { roles: ["adminGatheringService", "adminStream", "adminCouncil"] }
      ]
    )
    @cypher(
      statement: """
           MATCH (constituency:Constituency {id: $constituencyId})
           	SET constituency.name = $name

           WITH constituency
              CALL {
              	WITH constituency

                  MATCH (council:Council {id: $councilId})
                  OPTIONAL MATCH (constituency)<-[r:HAS]-()
                  DELETE r
                  MERGE (council)-[:HAS]->(constituency)
              	RETURN count(constituency)
              	}
      MATCH (constituency)<-[:LEADS]-(leader:Member)
      RETURN constituency
      """
    )
  UpdateBacentaDetails(
    bacentaId: ID!
    bacentaName: String!
    constituencyId: ID!
  ): Bacenta
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (bacenta:Bacenta {id: $bacentaId})
      	SET bacenta.name = $bacentaName

      WITH bacenta
         CALL {
         	WITH bacenta
      		OPTIONAL MATCH (constituency:Constituency {id: $constituencyId})

            OPTIONAL MATCH (bacenta)<-[r:HAS]-()
            DELETE r
            MERGE (constituency)-[:HAS]->(bacenta)
         	RETURN count(bacenta)
         	}
      MATCH (bacenta)<-[:LEADS]-(leader:Member)
      RETURN bacenta
      """
    )

  UpdateSontaDetails(sontaId: ID!, sontaName: String!): Sonta
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
      MATCH (sonta:Sonta {id: $sontaId})
      	SET sonta.name = $sontaName

      WITH sonta
      MATCH (sonta)<-[:LEADS]-(leader:Member)
      RETURN sonta
      """
    )

  UpdateFellowshipDetails(
    id: ID!
    name: String!
    meetingDay: String
    venueLongitude: Float
    venueLatitude: Float
  ): Fellowship
    @auth(
      rules: [
        {
          roles: [
            "adminGatheringService"
            "adminStream"
            "adminCouncil"
            "adminConstituency"
          ]
        }
      ]
    )
    @cypher(
      statement: """
               MATCH (fellowship:Fellowship {id: $id})
               	SET fellowship.name = $name
              	SET fellowship.location = point({latitude:toFloat($venueLatitude), longitude:toFloat($venueLongitude), crs:'WGS-84'})

               WITH fellowship
                    CALL {
                     	WITH fellowship
                      WITH fellowship WHERE $meetingDay IS NOT NULL
                      MATCH (meetingDay:ServiceDay {day: $meetingDay})
                      OPTIONAL MATCH (fellowship)-[r:MEETS_ON]->()
                      DELETE r
                      MERGE (fellowship)-[:MEETS_ON]->(meetingDay)
                     	RETURN count(fellowship)
                     	}

      RETURN fellowship
      """
    )
  #DIFFERENT LOG HISTORY MUTATIONS
  ConnectChurchHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church {id: $churchId})
      WHERE church:Bacenta OR church:Constituency OR church:Sonta
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (church)-[:HAS]->(downRelatedChurch)
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r1:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r1.current=true
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)
      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  ConnectFellowshipHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:Fellowship {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]->(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (upRelatedChurch)-[:HAS]->(church)
      MATCH (upRelatedChurch)-[r2:HAS_HISTORY]->(upHistory:ServiceLog) WHERE r2.current=true

      MERGE (upHistory)-[:HAS]->(churchHistory)

      RETURN churchHistory
      """
    )
  ConnectGatheringServiceHistory(churchId: ID!): [ServiceLog]
    @cypher(
      statement: """
      MATCH (church:GatheringService {id: $churchId})
      MATCH (church)-[r:HAS_HISTORY]-(churchHistory:ServiceLog) WHERE r.current=true
      MATCH (downRelatedChurch)-[:HAS]->(church)
      MATCH (downRelatedChurch)-[r2:HAS_HISTORY]->(downHistory:ServiceLog) WHERE r2.current=true

      MERGE (churchHistory)-[:HAS]->(downHistory)

      RETURN churchHistory
      """
    )

  LogFellowshipHistory(
    fellowshipId: ID!
    historyRecord: String!
    oldLeaderId: ID
    newLeaderId: ID
    oldBacentaId: ID
    newBacentaId: ID
  ): Fellowship
    @cypher(
      statement: """
      MATCH  (fellowship:Fellowship {id: $fellowshipId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (fellowship)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)


      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $oldBacentaId IS NOT NULL
        MATCH (oldBacenta:Bacenta {id: $oldBacentaId})
        MERGE (oldBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,fellowship
      CALL{
        WITH log
        WITH log WHERE $newBacentaId IS NOT NULL
        MATCH (newBacenta:Bacenta {id: $newBacentaId})
        MERGE (newBacenta)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN fellowship
      """
    )
  LogBacentaHistory(
    bacentaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newconstituencyId: ID
    oldconstituencyId: ID
  ): Bacenta
    @cypher(
      statement: """
       MATCH  (bacenta:Bacenta {id: $bacentaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (bacenta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
        MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,bacenta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH (log)<-[r0:HAS_HISTORY]-()
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $oldconstituencyId IS NOT NULL
         MATCH (oldconstituency:Constituency {id: $oldconstituencyId})
         MERGE (oldconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       WITH log,bacenta
       CALL {
         WITH log
         WITH log WHERE $newconstituencyId IS NOT NULL
         MATCH (newconstituency:Constituency {id: $newconstituencyId})
         MERGE (newconstituency)-[:HAS_HISTORY]->(log)
         RETURN COUNT(log)
       }

       RETURN bacenta
      """
    )
  LogConstituencyHistory(
    constituencyId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newCouncilId: ID
    oldCouncilId: ID
  ): Constituency
    @cypher(
      statement: """
      MATCH  (constituency:Constituency {id: $constituencyId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (constituency)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,constituency
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $oldCouncilId IS NOT NULL
        MATCH (council:Council {id: $oldCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,constituency
      CALL {
        WITH log
        WITH log WHERE $newCouncilId IS NOT NULL
        MATCH (council:Council {id: $newCouncilId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN constituency
      """
    )

  LogCouncilHistory(
    councilId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newStreamId: ID
    oldStreamId: ID
  ): Council
    @cypher(
      statement: """
      MATCH  (council:Council {id: $councilId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (council)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,council
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $oldStreamId IS NOT NULL
        MATCH (council:Council {id: $oldStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,council
      CALL {
        WITH log
        WITH log WHERE $newStreamId IS NOT NULL
        MATCH (council:Council {id: $newStreamId})
        MERGE (council)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN council
      """
    )

  LogStreamHistory(
    streamId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
    newGatheringServiceId: ID
    oldGatheringServiceId: ID
  ): Stream
    @cypher(
      statement: """
      MATCH  (stream:Stream {id: $streamId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (log:HistoryLog {id: apoc.create.uuid()})
        SET log.historyRecord = $historyRecord,
          log.timeStamp = datetime()
      MERGE (date:TimeGraph {date: date()})
      MERGE (stream)-[r:HAS_HISTORY]->(log)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)

      WITH log,stream
      CALL{
        WITH log
        WITH log WHERE $newLeaderId IS NOT NULL
      MATCH (newLeader:Member {id: $newLeaderId})
        SET log :ServiceLog
        WITH log, newLeader
      OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
        SET r0.current = false
        WITH log,newLeader
      CREATE (newLeader)-[r:HAS_HISTORY]->(log)
         SET r.current = true
         WITH log
      RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldLeaderId IS NOT NULL
        MATCH (oldLeader:Member {id: $oldLeaderId})
        CREATE (oldLeader)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }


      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $oldGatheringServiceId IS NOT NULL
        MATCH (stream:Stream {id: $oldGatheringServiceId})
        MERGE (stream)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      WITH log,stream
      CALL {
        WITH log
        WITH log WHERE $newGatheringServiceId IS NOT NULL
        MATCH (stream:Stream {id: $newGatheringServiceId})
        MERGE (stream)-[:HAS_HISTORY]->(log)
        RETURN COUNT(log)
      }

      RETURN stream
      """
    )

  LogSontaHistory(
    sontaId: ID!
    historyRecord: String!
    newLeaderId: ID
    oldLeaderId: ID
  ): Sonta
    @cypher(
      statement: """
       MATCH  (sonta:Sonta {id: $sontaId})
       MATCH (admin:Member {auth_id: $auth.jwt.sub})
       CREATE (log:HistoryLog {id: apoc.create.uuid()})
         SET log.historyRecord = $historyRecord,
           log.timeStamp = datetime()
       MERGE (date:TimeGraph {date: date()})
       MERGE (sonta)-[r:HAS_HISTORY]->(log)
       MERGE (log)-[:RECORDED_ON]->(date)
       MERGE (log)-[:LOGGED_BY]->(admin)

       WITH log,sonta
       CALL{
         WITH log
         WITH log WHERE $newLeaderId IS NOT NULL
       MATCH (newLeader:Member {id: $newLeaderId})
      OPTIONAL MATCH (oldLeader:Member {id: $oldLeaderId})
         SET log :ServiceLog
         WITH log, newLeader,oldLeader
       OPTIONAl MATCH ()-[r0:HAS_HISTORY]->(log)
         SET r0.current = false
         WITH log,newLeader,oldLeader
       CREATE (oldLeader)-[:HAS_HISTORY]->(log)
       CREATE (newLeader)-[r:HAS_HISTORY]->(log)
          SET r.current = true
          WITH log
       RETURN COUNT(log)
       }


       RETURN sonta
      """
    )

  #SERVICE RECORDS MUTATIONS
  RecordService(
    id: ID!
    serviceDate: String!
    attendance: Int!
    income: Float!
    foreignCurrency: String
    numberOfTithers: Int
    treasurers: [ID]!
    treasurerSelfie: String!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.income = $income,
        serviceRecord.foreignCurrency = $foreignCurrency,
        serviceRecord.numberOfTithers = $numberOfTithers,
        serviceRecord.treasurerSelfie = $treasurerSelfie,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Constituency
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      WITH serviceRecord
      UNWIND $treasurers AS treasurerId WITH treasurerId, serviceRecord
      MATCH (treasurer:Member {id: treasurerId})
      MERGE (treasurer)-[:WAS_TREASURER_FOR]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordCancelledService(
    id: ID!
    serviceDate: String!
    noServiceReason: String!
  ): NoService
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord:NoService {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.noServiceReason = $noServiceReason

      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Constituency
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  RecordServiceNoOffering(
    id: ID!
    serviceDate: String!
    attendance: Int!
    servicePicture: String!
  ): ServiceRecord
    @cypher(
      statement: """
      CREATE (serviceRecord:ServiceRecord {created_at:datetime()})
        SET serviceRecord.id = apoc.create.uuid(),
        serviceRecord.attendance = $attendance,
        serviceRecord.servicePicture = $servicePicture
      WITH serviceRecord
      MATCH (church {id:$id}) WHERE church:Fellowship OR church:Bacenta OR church:Sonta OR church:Constituency
      MATCH (church)-[has_history:HAS_HISTORY]->(log:HistoryLog) WHERE has_history.current = true
      MATCH (leader:Member {auth_id: $auth.jwt.sub})

      MERGE (serviceRecord)-[:LOGGED_BY]->(leader)
      MERGE (serviceDate:TimeGraph {date:date($serviceDate)})
      MERGE (serviceRecord)-[:SERVICE_HELD_ON]->(serviceDate)
      MERGE (log)-[:HAS_RECORD]->(serviceRecord)

      RETURN serviceRecord
      """
    )

  #Set Fellowship to be 'OnVacation
  SetVacationFellowship(fellowshipId: ID!): Fellowship
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' Fellowship went on vacation mode'

      WITH log,fellowship
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (bacenta)-[:HAS_HISTORY]->(log)

      SET fellowship:Vacation
      REMOVE fellowship:ActiveFellowship

      RETURN fellowship
      """
    )

  #DELETE OPERATIONS
  # In the context of church data we never delete, we only render inactive
  CloseDownFellowship(fellowshipId: ID!): Fellowship
  CloseDownBacenta(bacentaId: ID!): Bacenta

  CloseDownConstituency(constituencyId: ID!): Constituency
    @cypher(
      statement: """
      MATCH (constituency:Constituency {id:$constituencyId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MATCH (constituency)<-[:HAS]-(council:Council)
      OPTIONAL MATCH (constituency)-[:HAS]->(bacentas)-[:HAS]->(fellowships)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = constituency.name + ' Constituency was closed down under ' + council.name +' Council'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (council)-[:HAS_HISTORY]->(log)
      MERGE (council)-[:HAS_HISTORY]->(log)

      SET constituency:ClosedConstituency, bacentas:ClosedBacenta, fellowships:ClosedFellowship
      REMOVE constituency:Constituency,bacentas:Bacenta,fellowships:Fellowship

      RETURN constituency
      """
    )
  CloseDownCouncil(councilId: ID!): Council
    @cypher(
      statement: """
      MATCH (council:Council {id:$councilId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MATCH (council)<-[:HAS]-(stream:Stream)
      OPTIONAL MATCH (council)-[:HAS]->(constituencies)-[:HAS]->(bacentas)-[:HAS]->(fellowships)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = council.name + ' Council was closed down under ' + stream.name +' Stream'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (stream)-[:HAS_HISTORY]->(log)
      MERGE (stream)-[:HAS_HISTORY]->(log)

      SET council:ClosedCouncil, constituencies:ClosedConstituency, bacentas:ClosedBacenta, fellowships:ClosedFellowship
      REMOVE council:Council,constituencies:Constituency,bacentas:Bacenta, fellowships:Fellowship

      RETURN council
      """
    )
  CloseDownStream(streamId: ID!): Stream
    @cypher(
      statement: """
      MATCH (stream:Stream {id:$streamId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      MATCH (stream)<-[:HAS]-(gatheringService:GatheringService)
      OPTIONAL MATCH (stream)-[:HAS]->(council)-[:HAS]->(constituencies)-[:HAS]->(bacentas)-[:HAS]->(fellowships)

      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = stream.name + ' Stream was closed down under ' + gatheringService.name +' Gathering Service'


      MERGE (date:TimeGraph {date:date()})
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (stream)-[:HAS_HISTORY]->(log)
      MERGE (gatheringService)-[:HAS_HISTORY]->(log)

      SET stream:ClosedStream, councils:ClosedCouncil, constituencies:Closedconstituency, bacentas:ClosedBacenta, fellowships:ClosedFellowship
      REMOVE stream:Stream, council:Council, constituencies:Constituency,bacentas:Bacenta,fellowships:Fellowship

      RETURN stream
      """
    )

  #CHURCH CONVERSIONS
  MakeFellowshipIntoBacenta(fellowshipId: ID!): Bacenta
    @cypher(
      statement: """
      MATCH (fellowship:Fellowship {id:$fellowshipId})
      MATCH (admin:Member {auth_id: $auth.jwt.sub})
      CREATE (newFellowship:Fellowship {id:apoc.create.uuid()})
       SET newFellowship.name = fellowship.name,
       newFellowship.location = fellowship.location
      CREATE (log:HistoryLog {id:apoc.create.uuid()})
        SET log.timeStamp = datetime(),
        log.historyRecord = fellowship.name + ' was made into a Bacenta with '+ newFellowship.name+' as a fellowship under it.'

      WITH newFellowship, log, fellowship
      MATCH (fellowship)<-[hasFellowship:HAS]-(:Bacenta)<-[:HAS]-(constituency)
      MATCH (fellowship)-[meetsOnDay:MEETS_ON]->(meetingDay)
      MATCH (fellowship)<-[belongsTo:BELONGS_TO]-(member:Member)
      MATCH (fellowship)<-[:LEADS]-(leader:Member)

      MERGE (date:TimeGraph {date:date()})
      MERGE (constituency)-[:HAS]->(fellowship)
      MERGE (newFellowship)-[:MEETS_ON]->(meetingDay)
      MERGE (newFellowship)<-[:LEADS]-(leader)
      MERGE (member)-[:BELONGS_TO]->(newFellowship)
      MERGE (fellowship)-[:HAS]->(newFellowship)

      DELETE hasFellowship,meetsOnDay,belongsTo

      MERGE (log)-[:RECORDED_ON]->(date)
      MERGE (log)-[:LOGGED_BY]->(admin)
      MERGE (fellowship)-[:HAS_HISTORY]->(log)
      MERGE (newFellowship)-[:HAS_HISTORY]->(log)

      SET fellowship:Bacenta
      REMOVE fellowship.location
      REMOVE fellowship:Fellowship
      RETURN fellowship
      """
    )
}
